1 将命名空间有ControlzEx替换为GenLibrary.ControlzEx
  在WindowChromeBehavior.cs中修改代码：
    this.isWindwos10OrHigher = Environment.OSVersion.Version > new Version(6, 2);
	在FixMaximizedWindow()中修改：
	if (this.isWindwos10OrHigher == false|| AssociatedObject.WindowStyle==WindowStyle.None)
	在OnAttached()中添加事件：
	this.AssociatedObject.ContentRendered += AssociatedObject_ContentRendered;
	并删除代码：FixMaximizedWindow();
	在Cleanup()中删除事件：
	this.AssociatedObject.ContentRendered -= AssociatedObject_ContentRendered;
	添加事件处理程序：
	 private void AssociatedObject_ContentRendered(object sender, EventArgs e)
        {
            FixMaximizedWindow();
        }
2 在NativeMethods类中添加：
 [DllImport("user32.dll", CharSet = CharSet.Auto, ExactSpelling = true)]
        public static extern IntPtr GetActiveWindow();
/// <summary>
		/// 鼠标的各种消息
		/// </summary>
		public enum HitTest : int
		{
			HTERROR = -2,

			HTTRANSPARENT = -1,

			HTNOWHERE = 0,

			HTCLIENT = 1,

			HTCAPTION = 2,

			HTSYSMENU = 3,

			HTGROWBOX = 4,

			HTSIZE = HTGROWBOX,

			HTMENU = 5,

			HTHSCROLL = 6,

			HTVSCROLL = 7,

			HTMINBUTTON = 8,

			HTMAXBUTTON = 9,

			HTLEFT = 10,

			HTRIGHT = 11,

			HTTOP = 12,

			HTTOPLEFT = 13,

			HTTOPRIGHT = 14,

			HTBOTTOM = 15,

			HTBOTTOMLEFT = 16,

			HTBOTTOMRIGHT = 17,

			HTBORDER = 18,

			HTREDUCE = HTMINBUTTON,

			HTZOOM = HTMAXBUTTON,

			HTSIZEFIRST = HTLEFT,

			HTSIZELAST = HTBOTTOMRIGHT,

			HTOBJECT = 19,

			HTCLOSE = 20,

			HTHELP = 21

		}
		// MONITORINFOEX structure, Monitor information used by GetMonitorInfo function
		[StructLayout( LayoutKind.Sequential )]
		public class MONITORINFOEX
		{
			public int cbSize;
			public RECT rcMonitor; // The display monitor rectangle
			public RECT rcWork; // The working area rectangle
			public int dwFlags;
			[MarshalAs( UnmanagedType.ByValArray, SizeConst = 0x20 )]
			public char[] szDevice;
		}
		// Get the working area of the specified monitor
		[DllImport( "user32.dll" )]
		public static extern bool GetMonitorInfo( HandleRef hmonitor, [In, Out] MONITORINFOEX monitorInfo );
		 public static IntPtr GetHandle<TVisual>(this TVisual visual) where TVisual : System.Windows.Media.Visual
        {
            if (null == visual)
                return IntPtr.Zero;

            System.Windows.Interop.HwndSource hwndSource = System.Windows.PresentationSource.FromVisual(visual) as System.Windows.Interop.HwndSource;
           
            if (null != hwndSource)
                return hwndSource.Handle;

            return IntPtr.Zero;
        }
3 AutoMove ToolTip
<Button Margin="5"
        Padding="5"
        Content="Test Button 2"
        ToolTipService.ShowDuration="20000">
    <Button.ToolTip>
        <ToolTip local:ToolTipAssist.AutoMove="True">
            <ToolTip.Template>
                <ControlTemplate>
                    <Grid>
                        <Border Background="Gray"
                                BorderBrush="Black"
                                BorderThickness="1"
                                Opacity="0.9"
                                SnapsToDevicePixels="True" />
                        <TextBlock Margin="5"
                                    Foreground="WhiteSmoke"
                                    FontSize="22"
                                    Text="ToolTipHelper AutoMove sample"
                                    TextOptions.TextFormattingMode="Display"
                                    TextOptions.TextRenderingMode="ClearType" />
                    </Grid>
                </ControlTemplate>
            </ToolTip.Template>
        </ToolTip>
    </Button.ToolTip>
</Button>

4 PackIconBase

A base class to help drive a common method for creating icon packs in WPF.

To create a new icon pack follow these steps: 

Define a key (typically an  enum ):

public enum PackIconKind
{
    Happy,
    Sad
}

Subclass  PackIconBase , adding
•Default style key
•A factory providing Path data for each key

public class PackIcon : PackIconBase<PackIconKind>
{        
    static PackIcon()
    {
        DefaultStyleKeyProperty.OverrideMetadata(typeof(PackIcon), new FrameworkPropertyMetadata(typeof(PackIcon)));
    }     

    public PackIcon() : base(CreateIconData)
    { }

    private static IDictionary<PackIconKind, string> CreateIconData()
    {
        return new Dictionary<PackIconKind, string>
        {
            {PackIconKind.Happy, "M20,12A8,8 0 0,0 12,4A8,8 0 0,0 4,12A8,8 0 0,0 12,20A8,8 0 0,0 20,12M22,12A10,10 0 0,1 12,22A10,10 0 0,1 2,12A10,10 0 0,1 12,2A10,10 0 0,1 22,12M10,9.5C10,10.3 9.3,11 8.5,11C7.7,11 7,10.3 7,9.5C7,8.7 7.7,8 8.5,8C9.3,8 10,8.7 10,9.5M17,9.5C17,10.3 16.3,11 15.5,11C14.7,11 14,10.3 14,9.5C14,8.7 14.7,8 15.5,8C16.3,8 17,8.7 17,9.5M12,17.23C10.25,17.23 8.71,16.5 7.81,15.42L9.23,14C9.68,14.72 10.75,15.23 12,15.23C13.25,15.23 14.32,14.72 14.77,14L16.19,15.42C15.29,16.5 13.75,17.23 12,17.23Z"},
            {PackIconKind.Sad, "M20,12A8,8 0 0,0 12,4A8,8 0 0,0 4,12A8,8 0 0,0 12,20A8,8 0 0,0 20,12M22,12A10,10 0 0,1 12,22A10,10 0 0,1 2,12A10,10 0 0,1 12,2A10,10 0 0,1 22,12M15.5,8C16.3,8 17,8.7 17,9.5C17,10.3 16.3,11 15.5,11C14.7,11 14,10.3 14,9.5C14,8.7 14.7,8 15.5,8M10,9.5C10,10.3 9.3,11 8.5,11C7.7,11 7,10.3 7,9.5C7,8.7 7.7,8 8.5,8C9.3,8 10,8.7 10,9.5M12,14C13.75,14 15.29,14.72 16.19,15.81L14.77,17.23C14.32,16.5 13.25,16 12,16C10.75,16 9.68,16.5 9.23,17.23L7.81,15.81C8.71,14.72 10.25,14 12,14Z""}
        };
    }
}

Provide a default style (typically in your Generic.xaml, e.g:

<Style TargetType="{x:Type local:PackIcon}">
    <Setter Property="Height" Value="16" />
    <Setter Property="Width" Value="16" />
    <Setter Property="HorizontalAlignment" Value="Left" />
    <Setter Property="VerticalAlignment" Value="Top" />
    <Setter Property="IsTabStop" Value="False" />
    <Setter Property="Template">
        <Setter.Value>
            <ControlTemplate TargetType="{x:Type local:PackIcon}">
                <Viewbox>
                    <Canvas Width="24" Height="24">
                        <Path Data="{Binding Data, RelativeSource={RelativeSource TemplatedParent}}"                                  
                              Fill="{TemplateBinding Foreground}" />
                    </Canvas>
                </Viewbox>
            </ControlTemplate>
        </Setter.Value>
    </Setter>
</Style>

and finally...

Your users should now have a simple way to use your icon pack in their applications:

<ns:PackIcon Kind="HappyIcon" />
